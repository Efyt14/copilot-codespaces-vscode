# CÃ³digo para generar el sÃ­mbolo tipo pica utilizando splines cÃºbicos de Hermite.

#Definimos la interpolacion de Hermite
import numpy as np
import matplotlib.pyplot as plt
import math

def dividedDifferences(data):
    M = []
    nodes = []
    indices = []
    row = []
    for i in range(len(data)):
        for j in range(1, len(data[i])):
            nodes.append(data[i][0])
            row.append(data[i][1])
            indices.append(i)
    M.append(row)
    n = len(nodes)

    for i in range(1, n):
        row = []
        for j in range(n - i):
            if (nodes[j] != nodes[j + i]):
                # caso en el que los nodos son diferentes: aplicar la diferencia dividida habitual
                row.append((M[i - 1][j] - M[i - 1][j + 1]) / (nodes[j] - nodes[j + i]))
            else:
                # caso en el que el primer y Ãºltimo nodo coinciden: aplicar la derivada
                row.append(data[indices[j]][i + 1] / math.factorial(i))
        M.append(row)

    return [row[0] for row in M]

def hermiteInterpolation(t, data):
    dd = dividedDifferences(data)
    nodes = []
    for i in range(len(data)):
        for j in range(1, len(data[i])):
            nodes.append(data[i][0])
    n = len(nodes) - 1

    result = dd[0]
    product = 1
    for i in range(1, n + 1):
        product = product * (t - nodes[i - 1])
        result = result + dd[i] * product
    return result

a = 2 #a is a variable parameter that has to be fine-tuned to get a good enough result

def spadeXUpper(t):
  if t>=0 and t<= 1:
    return hermiteInterpolation(t,[[0,0,a/10],[1,1,a]])
  elif t>1 and t<= 1.7:
    return hermiteInterpolation(t,[[1,1,a/2],[1.7,1.7,-a/10]])
  elif t>1.7 and t<= 2:
    return hermiteInterpolation(t,[[1.7,1.7,a/10],[2,2,0]])
  elif t>2 and t<= 3:
    return hermiteInterpolation(t,[[2,2,0],[3,3,0]])

def spadeYUpper(t):
  if t>=0 and t<= 1:
    return hermiteInterpolation(t,[[0,0,a],[1,4,0]])
  elif t>1 and t<= 1.7:
    return hermiteInterpolation(t,[[1,4,0],[1.7,2,-a]])
  elif t>1.7 and t<= 2:
    return hermiteInterpolation(t,[[1.7,2,a],[2,4,0]])
  elif t>2 and t<= 3:
    return hermiteInterpolation(t,[[2,4,0],[3,4,0]])


def spadeXLower(t):
  if t>=0 and t<= 1:
    return hermiteInterpolation(t,[[0,0,0],[1,1,0]])
  elif t>1 and t<= 1.2:
    return hermiteInterpolation(t,[[1,1,a/10],[1.2,1.2,a]])
  elif t>1.2 and t<= 2:
    return hermiteInterpolation(t,[[1.2,1.2,-a/10],[2,2,a]])
  elif t>2 and t<= 3:
    return hermiteInterpolation(t,[[2,2,a],[3,3,a/10]])

def spadeYLower(t):
  if t>=0 and t<= 1:
    return hermiteInterpolation(t,[[0,0,0],[1,0,0]])
  elif t>1 and t<= 1.2:
    return hermiteInterpolation(t,[[1,0,a],[1.2,2,a]])
  elif t>1.2 and t<= 2:
    return hermiteInterpolation(t,[[1.2,2,-a/2],[2,0,a/10]])
  elif t>2 and t<= 3:
    return hermiteInterpolation(t,[[2,0,0],[3,4,a]])

fig, ax = plt.subplots()

t = np.linspace(0,3,200)
#plot upper part
xUpper = [spadeXUpper(s) for s in t]
yUpper = [spadeYUpper(s) for s in t]
ax.plot(xUpper,yUpper,color="orange")

#plot lower part
xUpper = [spadeXLower(s) for s in t]
yUpper = [spadeYLower(s) for s in t]
ax.plot(xUpper,yUpper,color="orange")

plt.axis('equal') #This forces the aspect ratio to be 1:1
plt.show()
